#pragma config(Sensor, dgtl1,  xAxisEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  yAxisEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  penEncoder,     sensorQuadEncoder)
#pragma config(Motor,  port2,           xAxis,         tmotorServoContinuousRotation, PIDControl, encoderPort, dgtl1)
#pragma config(Motor,  port3,           yAxis,         tmotorServoContinuousRotation, PIDControl, reversed, encoderPort, dgtl3)
#pragma config(Motor,  port4,           penController, tmotorServoContinuousRotation, PIDControl, encoderPort, dgtl5)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
const int PENSPEED = 10;
const int AXISSPEED = 10;

// X and y axis range (will always have a lowest value of zero)
// The max number these can be set to is +/-32768, as they must be an int value to compare correctly
const int XAXISMAX = 10000;
const int YAXISMAX = 10000;




// Sets x and y axis motors to zero
void ZeroAxisMotors() {
	motor[xAxis] = 0;
	motor[yAxis] = 0;
}

// Sets x and y Axis encoders to zero
void ZeroAxisEncoders() {
	SensorValue[xAxisEncoder] = 0;
	SensorValue[yAxisEncoder] = 0;
}

// Tells penController to move forward 15 ticks, simulating a pen rising
void penUp() {
	SensorValue[penEncoder] = 0;
	motor[penController] = PENSPEED;
	while(SensorValue[penEncoder] < 15) {
	}
	motor[penController] = 0;
}

// Tells penController to move backward 15 ticks, simulating a pen being brought down
void penDown() {
	SensorValue[penEncoder] = 0;
	motor[penController] = -1 * PENSPEED;
	while(SensorValue[penEncoder] > -15) {
	}
	motor[penController] = 0;
}

// Greatest Common Denominator Function - Why couldn't this have been c++!!!
// Uses the Euclidean Algorithm for recursive calculation
// Will only accept positive integers
int gcd(int a, int b) {
	int r = 0;
	if(a == 0) {
		return b;
	}
	if(b == 0) {
		return a;
	}
	if(b > a) {
		int temp = a;
		a = b;
		b = temp;
	}
	while(r * b <= a) {
		r++;
	}
	r--;
	return gcd(b, a - (r * b));
}



// Moves the X axis motor by the specified number of ticks
// Will accept both negative and positive integers to indicate direction
void moveHoriz(int tickNum) {
	int tickGoal = tickNum + SensorValue[xAxisEncoder];
	motor[xAxis] = (tickNum / abs(tickNum)) * AXISSPEED;
	if(motor[xAxis] > 0) {
		while(SensorValue[xAxisEncoder] < tickGoal) {
		}
	} else {
		while(SensorValue[xAxisEncoder] > tickGoal) {
		}
	}
	motor[xAxis] = 0;
}

// Moves the Y axis motor by the specified number of ticks
// Will accept both negative and positive integers to indicate direction
void moveVert(int tickNum) {
	int tickGoal = tickNum + SensorValue[yAxisEncoder];
	motor[yAxis] = (tickNum / abs(tickNum)) * AXISSPEED;
	if(motor[yAxis] > 0) {
		while(SensorValue[yAxisEncoder] < tickGoal) {
		}
	} else {
		while(SensorValue[yAxisEncoder] > tickGoal) {
		}
	}
	motor[yAxis] = 0;
}

// Will take the slope of the line formed from the current point and the x and y coordinates passed into the function to move to that location (will not work for vertical or horizontal lines)
// This is done to accurately plot different points and draw lines between them without having to move on each axis individually
// This function is written assuming the motor controller input is scaled linearly, rather than exponentially or logarithmically. This, however, might not be the case, and needs to be tested further
void moveToPoint(int x2, int y2) {
	int x1 = SensorValue[xAxisEncoder];
	int y1 = SensorValue[yAxisEncoder];
	int delta_y = y2 - y1;
	int delta_x = x2 - x1;
	int scale = gcd(abs(delta_x), abs(delta_y));
	delta_y = delta_y / scale;
	delta_x = delta_x / scale;
	motor[xAxis] = (delta_x * 127) / (XAXIXMAX / scale);
	motor[yAxis] = (delta_y * 127) / (YAXIXMAX / scale);
	bool xGoalReached = false;
	bool yGoalReached = false;
	while(xGoalReached == false && yGoalReached == false) {
		if(xGoalReached == false) {
			if(motor[xAxis] > 0) {
				if(SensorValue[xAxisEncoder] >= x2) {
					xGoalReached = true;
				}
			} else {
				if(SensorValue[xAxisEncoder] <= x2) {
					xGoalReached = true;
				}
			}
		}
		if(yGoalReached == false) {
			if(motor[yAxis] > 0) {
				if(SensorValue[yAxisEncoder] >= x2) {
					yGoalReached = true;
				}
			} else {
				if(SensorValue[yAxisEncoder] <= x2) {
					yGoalReached = true;
				}
			}
		}
	}
	motor[xAxis] = 0;
	motor[yAxis] = 0;
}



// The main loop will be able to handle taking a mathimatical function and generating points that will then be passed to other functions to move the pen
// Hopefully there will be the integeration of the vex lcd screen to both view the current fucntion and its progress
// There might also be an addition of polar coordinates after testing the limitations of the trigonometric functions
task main()
{



}
